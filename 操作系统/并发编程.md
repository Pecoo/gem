1. **共享资源是并发编程问题的根源**，线程私有资源是不会出现线程安全问题
2. **竞态条件 & 临界区**
3. 解决并发问题的利器：原子性，即指令要么没有执行，要么执行完毕，不会有中间状态
4. **并发编程需要解决的两类问题：互斥访问，同步等待**
    - 互斥访问
        多个线程访问共享资源时一次有且只有一个线程来访问该共享资源
    - 同步等待
        一个线程需要等待另一个线程完成特定操作后才可以继续运行
5. CAS：Compare & Swap
6. 使用锁时的思考：
    - 锁是用来保护临界资源的
    - 这些共享资源一定要在多个线程中使用吗
7. **锁的意义：给了程序员一点对调度的控制权**
8. #####################################
9. 在同步问题中，线程已经分成了两类；
    - 一类是等待条件成立的线程
    - 一类是修改条件的线程
10. 同步问题可以分解为两个子问题来解决：
    - 使用锁来解决资源（条件）的互斥访问
    - 使用wait（） + signal 来解决线程等待与唤醒问题
11. **同步问题：**
    - 等待子线程运行结束的正确解法：条件变量 + 线程是否运行完成的标志 + 锁
    - 生产者消费者问题：
12.**当阻塞线程被唤醒后我们仅仅知道共享资源状态发生过变化，至于是不是依然满足运行条件是不确定的**


