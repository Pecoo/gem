1. **什么是GC**
    - 需要GC的内存区域 ：Heap
    - GC的对象是什么？
        需要回收的对象就是已经没有存活的对象，判断一个对象是否存活有2中方法：
        - 引用计数：无法解决循环引用的问题
        - 可达性分析：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
    - 在Java语言中，GC Roots包括：

        - 虚拟机栈中引用的对象。

        - 方法区中类静态属性实体引用的对象。

        - 方法区中常量引用的对象。

        - 本地方法栈中JNI引用的对象。
    - 什么时候触发GC？
        - 程序调用System.gc
        - 系统自身决定，启动gc线程时应用线程会暂停
2. **GC常用算法**
    - 标记-清除算法：为每个对象存储一个标记位，记录对象的状态（活着或是死亡）。分为两个阶段，一个是标记阶段，这个阶段内，为每个对象更新标记位，检查对象是否死亡；第二个阶段是清除阶段，该阶段对死亡的对象进行清除，执行 GC 操作
        - 优点：不需要移动对象的位置
        - 缺点：造成很多内存碎片
    - 标记-整理算法：标记-压缩法是标记-清除法的一个改进版。同样，在标记阶段，该算法也将所有对象标记为存活和死亡两种状态；不同的是，在第二个阶段，该算法并没有直接对死亡的对象进行清理，而是将所有存活的对象整理一下，放到另一处空间，然后把剩下的所有对象全部清除。这样就达到了标记-整理的目的。
    - 复制算法：该算法将内存平均分成两部分，然后每次只使用其中的一部分，当这部分内存满的时候，将内存中所有存活的对象复制到另一个内存中，然后将之前的内存清空，只使用这部分内存，循环下去。
    - 分代收集算法：现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代(Young)和老年代(Tenure)。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。
